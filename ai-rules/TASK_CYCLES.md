# タスク種別ごとの実施サイクル

タスクの種類に応じて、専門エージェントを適切な順序で活用します。

**重要な原則:**
- 各フェーズで指摘事項があれば、修正後に再度同じエージェントでレビュー
- UI/UX実装を含む場合は、必ずdesignerエージェントを最初に通す
- すべてのタスクで最終的にtech-leadレビューを実施
- テストコードが関係する場合は、必ずqa-engineerレビューを実施
- ユーザーへの完了報告前に、すべてのレビューサイクルを完了すること

---

## 1. 新機能開発（UI/UX含む）

```
要件定義 → 設計 → 実装 → レビュー

1. product-manager エージェント
   ↓ 要件定義・仕様策定
2. designer エージェント
   ↓ UI/UXデザイン設計・レビュー
3. 実装（コード記述）
   ↓
4. designer エージェント（再度）
   ↓ 実装後のUI/UXレビュー
5. tech-lead エージェント
   ↓ コード品質レビュー
6. qa-engineer エージェント
   ↓ テストコードレビュー
7. ユーザーに完了報告
```

**適用例:**
- 新しい画面・コンポーネントの追加
- 新機能の実装
- ユーザー向け機能の追加

---

## 2. UI/UX改善・画面修正

```
設計 → 実装 → レビュー

1. designer エージェント
   ↓ UI/UXデザイン改善案レビュー
2. 実装（コード記述）
   ↓
3. designer エージェント（再度）
   ↓ 実装後のUI/UXレビュー
4. tech-lead エージェント
   ↓ コード品質レビュー
5. qa-engineer エージェント
   ↓ テストコードレビュー
6. ユーザーに完了報告
```

**適用例:**
- デザインの改善
- レイアウトの修正
- アクセシビリティの向上
- レスポンシブ対応

---

## 3. バグ修正

```
調査 → 修正 → レビュー

1. 実装（バグ修正）
   ↓
2. tech-lead エージェント
   ↓ コード品質・根本原因分析
3. qa-engineer エージェント
   ↓ テストコードレビュー（リグレッション防止）
4. ユーザーに完了報告
```

**適用例:**
- ロジックのバグ修正
- データ処理のエラー修正
- APIエラーの修正

**注意:**
- UI/UX関連のバグの場合は、designerエージェントも追加
- 根本原因分析を必ず実施
- リグレッションテストを追加

---

## 4. リファクタリング

```
設計 → 実装 → レビュー

1. tech-lead エージェント
   ↓ リファクタリング方針レビュー
2. 実装（リファクタリング）
   ↓
3. tech-lead エージェント（再度）
   ↓ コード品質レビュー
4. qa-engineer エージェント
   ↓ テストコードレビュー（既存機能の保証）
5. ユーザーに完了報告
```

**適用例:**
- コードの整理
- アーキテクチャの改善
- パフォーマンス改善（軽微）
- 技術的負債の解消

**注意:**
- 既存機能の動作保証が必須
- テストカバレッジを維持・向上
- 段階的なリファクタリングを推奨

---

## 5. テストコード追加・改善

```
設計 → 実装 → レビュー

1. qa-engineer エージェント
   ↓ テスト戦略・カバレッジレビュー
2. 実装（テストコード記述）
   ↓
3. qa-engineer エージェント（再度）
   ↓ テストコード品質レビュー
4. tech-lead エージェント
   ↓ コード品質レビュー
5. ユーザーに完了報告
```

**適用例:**
- カバレッジ向上
- エッジケーステスト追加
- E2Eテスト追加
- パフォーマンステスト追加

**注意:**
- テスト戦略を明確にする
- 既存テストとの重複を避ける
- テストの保守性を考慮

---

## 6. パフォーマンス最適化

```
調査 → 設計 → 実装 → レビュー

1. tech-lead エージェント
   ↓ ボトルネック分析・最適化方針レビュー
2. 実装（最適化）
   ↓
3. tech-lead エージェント（再度）
   ↓ コード品質・パフォーマンス改善レビュー
4. qa-engineer エージェント
   ↓ パフォーマンステストレビュー
5. ユーザーに完了報告
```

**適用例:**
- レンダリング最適化
- バンドルサイズ削減
- データベースクエリ最適化
- メモリ使用量削減

**注意:**
- 計測結果を明示（Before/After）
- トレードオフを明確にする
- パフォーマンステストを追加

---

## 7. 設計・アーキテクチャ変更

```
要件定義 → 設計 → 実装 → レビュー

1. product-manager エージェント
   ↓ ビジネス要件・影響範囲の確認
2. tech-lead エージェント
   ↓ アーキテクチャ設計レビュー
3. 実装（段階的に）
   ↓
4. tech-lead エージェント（再度）
   ↓ 実装レビュー
5. qa-engineer エージェント
   ↓ テスト戦略レビュー
6. ユーザーに完了報告
```

**適用例:**
- 状態管理の変更
- データモデルの変更
- API構造の変更
- 新しいライブラリの導入

**注意:**
- 段階的な移行を計画
- 既存機能への影響を最小化
- ドキュメントを必ず更新

---

## エージェント選択のクイックリファレンス

| タスクの特徴 | 主要エージェント | 補助エージェント |
|------------|----------------|----------------|
| UI/UXが関係する | designer | tech-lead, qa-engineer |
| 新機能追加 | product-manager | designer, tech-lead, qa-engineer |
| バグ修正 | tech-lead | qa-engineer |
| リファクタリング | tech-lead | qa-engineer |
| テスト関連 | qa-engineer | tech-lead |
| パフォーマンス | tech-lead | qa-engineer |
| アーキテクチャ | tech-lead | product-manager, qa-engineer |

---

## タスク開始前のチェックリスト

- [ ] タスクの種類を明確にする
- [ ] 適切な実施サイクルを選択する
- [ ] 必要なエージェントを特定する
- [ ] 専用ブランチを作成する（feat-*, fix-*, refactor-*）
- [ ] 設計書の更新要否を確認する

---

## タスク完了時のチェックリスト

- [ ] すべてのエージェントレビューが完了している
- [ ] 指摘事項をすべて修正している
- [ ] テストがパスしている（npm run test:fast）
- [ ] 型チェックがパスしている（npm run typecheck）
- [ ] 設計書を更新している（該当する場合）
- [ ] コミット・push・PR作成が完了している
- [ ] ユーザーに完了報告している

---

**ヒント**: タスクの種類が不明確な場合は、`task-coordinator` エージェントに相談して、適切なサイクルを提案してもらってください。
